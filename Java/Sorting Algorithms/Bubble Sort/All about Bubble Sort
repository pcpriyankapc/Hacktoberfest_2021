# What is Bubble Sort?

Bubble Sort is the simplest sorting algorithm that works by repeatedly swapping the adjacent elements if they are in wrong order.
Example: 
First Pass: 
( 5 1 4 2 8 ) –> ( 1 5 4 2 8 ), Here, algorithm compares the first two elements, and swaps since 5 > 1. 
( 1 5 4 2 8 ) –>  ( 1 4 5 2 8 ), Swap since 5 > 4 
( 1 4 5 2 8 ) –>  ( 1 4 2 5 8 ), Swap since 5 > 2 
( 1 4 2 5 8 ) –> ( 1 4 2 5 8 ), Now, since these elements are already in order (8 > 5), algorithm does not swap them.
Second Pass: 
( 1 4 2 5 8 ) –> ( 1 4 2 5 8 ) 
( 1 4 2 5 8 ) –> ( 1 2 4 5 8 ), Swap since 4 > 2 
( 1 2 4 5 8 ) –> ( 1 2 4 5 8 ) 
( 1 2 4 5 8 ) –>  ( 1 2 4 5 8 ) 
Now, the array is already sorted, but our algorithm does not know if it is completed. The algorithm needs one whole pass without any swap to know it is sorted.
Third Pass: 
( 1 2 4 5 8 ) –> ( 1 2 4 5 8 ) 
( 1 2 4 5 8 ) –> ( 1 2 4 5 8 ) 
( 1 2 4 5 8 ) –> ( 1 2 4 5 8 ) 
( 1 2 4 5 8 ) –> ( 1 2 4 5 8 ) 


# Problem Discussion

Here you are given an array(arr) of integers. You have to sort the given array in increasing order using bubble sort.

For example: Sample Input: (5 7 -2 4 1 3)

It's quite obvious that size of array is 5 and output for bubble sort on inputting any array will be the sorted array, i.e. (-2 1 3 4 7)

# Approach :

Let's say that elements of our input array are: (5, 9, 8, 2 and 1).

As the length of the array is 5 that means there will be a total of four iterations. And at the end of each iteration, the largest value will get placed at the correct position of the array. Let's take a look at that.

At the first iteration we compare 9 with 5, but 9 is not smaller than 5 therefore there will be no swapping.
Then 8 is compared with 9, since 8 is smaller than 9 therefore there will be swapping.
Then 2 is compared with 9, since 2 is smaller than 9 therefore there will be swapping.
Then 1 is compared with 9, since 1 is smaller than 9 therefore there will be swapping.
At last, the largest element that is 9 is placed at the last index of the array.
Since the largest element is placed at the right position, that is at the last index. So, next time, for loop of j will run for one iteration less.

Let's try to code this.

public static void bubbleSort(int[] arr) {
    int n = arr.length;
    for (int itr = 1; itr < n; itr++) {
      for (int j = 0; j < n - itr; j++) {
        if (isSmaller(arr, j + 1, j) == true) {
          swap(arr, j + 1, j);
        }
      }
    }
  }
  
First loop of itr, will run only for n-1 times because for n-1 iterations, n-1 largest elements of array will be placed at right positions.
Second loop of j, will only run for the first n-1 elements of the array, comparing the value of the jth index element with (j + 1)th index element. Because when the loop will run for (n-1)th index element nth element will automatically be taken into account.
While comparing values inside the loop, if the value of (j+1)th index element is smaller than jth index element then we simply swap the elements.

# Analysis
### Time Complexity :
#### Worst Case Time Complexity: O(n*n). Worst case is when the array is in reverse order.

#### Best Case Time Complexity: O(n) Best case is when the input array is already sorted.

#### Average Case Time Complexity: O(n*n). The inner loop does O(n) work on each iteration, and the outer loop runs for O(n) iterations, so the total work is O(n 2).

### SPACE COMPLEXITY :
Auxiliary Space: O(1), as no extra space is used.
